#pragma kernel CSMain
Texture2D<float4> InputTexture;
RWTexture2D<float4> Result;

static const float ZERO = 0.0;
static const float HALF_CONST = 0.5;
static const float ONE = 1.0;
static const float TWO = 2.0;
static const float ONE_SIXTH = (ONE / 6.0);
static const float ONE_THIRD = (ONE / 3.0);
static const float TWO_THIRDS = (TWO / 3.0);
static const float FOUR = 4.0;
static const float SIX = 6.0;
static const float MAGNITUDE_SCALE = 0.01;
static const float MAGNITUDE_SCALE_02 = (MAGNITUDE_SCALE * 0.2);
static const float MAGNITUDE_SCALE_04 = (MAGNITUDE_SCALE * 0.4);
static const float MAGNITUDE_SCALE_05 = (MAGNITUDE_SCALE * HALF_CONST);
static const float MAGNITUDE_SCALE_06 = (MAGNITUDE_SCALE * 0.6);
static const float MAGNITUDE_SCALE_09 = (MAGNITUDE_SCALE * 0.9);
static const float HUE_SCALE = (ONE / 360.0);
static const float3 LUMINANCE_WEIGHTS = float3(0.2126, 0.7152, 0.0722);
static const float GAMMA = 2.2;
static const float INV_GAMMA = (ONE / GAMMA);
static const float GAMMA_WHITE = 0.3;
static const float BRIGHTNESS_MAGNITUDE_SCALE = (MAGNITUDE_SCALE * 3.0);
static const float EXPOSURE_MAGNITUDE_SCALE = (MAGNITUDE_SCALE * 3.0);
static const float CONTRAST_MIDPOINT = 0.2;
static const float MIN_BLOCK_SIZE = 16.0;
static const float MAX_BLOCK_SIZE = 128.0;
static const float SHARPEN_THRESHOLD = 0.005;

float VibranceMagnitude;
float SaturationMagnitude;
float TemperatureMagnitude;
float TintMagnitude;
float HueMagnitude;
float ChannelBoostMagnitude;
float BrightnessMagnitude;
float ExposureMagnitude;
float ContrastMagnitude;
float BlackMagnitude;
float WhiteMagnitude;
float ShadowMagnitude;
float PixelateMagnitude;
float SharpenMagnitude;

float3 rgb_to_hsl(float3 rgb)
{
    float r = rgb.r, g = rgb.g, b = rgb.b;

    float max_c = max(max(r, g), b);
    float min_c = min(min(r, g), b);

    float l = (max_c + min_c) * HALF_CONST;
    float h = ZERO;
    float s = ZERO;

    if (max_c != min_c)
    {
        float delta = max_c - min_c;
        s = l > HALF_CONST ? delta / (TWO - max_c - min_c) : delta / (max_c + min_c);

        if (max_c == r)
        {
            h = (g - b) / delta + (g < b ? SIX : ZERO);
        }
        else if (max_c == g)
        {
            h = (b - r) / delta + TWO;
        }
        else
        {
            h = (r - g) / delta + FOUR;
        }
        h *= ONE_SIXTH;
    }

    return float3(h, s, l);
}

float hue_to_rgb(float p, float q, float t)
{
    t = frac(t);
    if (t < ONE_SIXTH)
        return p + (q - p) * SIX * t;
    if (t < HALF_CONST)
        return q;
    if (t < TWO_THIRDS)
        return p + (q - p) * (TWO_THIRDS - t) * SIX;
    return p;
}

float3 hsl_to_rgb(float3 hsl)
{
    float h = hsl.x, s = hsl.y, l = hsl.z;
    float r, g, b;

    if (s == ZERO)
    {
        r = g = b = l;
    }
    else
    {
        float q = l < HALF_CONST ? l * (ONE + s) : l + s - l * s;
        float p = TWO * l - q;

        r = hue_to_rgb(p, q, h + ONE_THIRD);
        g = hue_to_rgb(p, q, h);
        b = hue_to_rgb(p, q, h - ONE_THIRD);
    }

    return float3(r, g, b);
}

float calculate_luminance(float3 rgb)
{
    return dot(rgb, LUMINANCE_WEIGHTS);
}

float apply_vibrance(float s, float magnitude)
{
    magnitude *= MAGNITUDE_SCALE;
    return s * (ONE + magnitude * (ONE - s));
}

float apply_saturation(float s, float magnitude)
{
    magnitude *= MAGNITUDE_SCALE;
    float maxScale = (magnitude < ZERO) ? ONE + magnitude : ONE + magnitude * (TWO - ONE);
    return saturate(s * maxScale);
}

float3 apply_temperature(float3 rgb, float magnitude)
{
    float t = magnitude * MAGNITUDE_SCALE_04;
    float r_scale = exp(t);
    float b_scale = exp(-t);
    rgb.r *= r_scale;
    rgb.b *= b_scale;
    return saturate(rgb);
}

float3 apply_tint(float3 rgb, float magnitude)
{
    float alpha = saturate(abs(magnitude) * MAGNITUDE_SCALE_02);
    float3 tintColor = (magnitude > ZERO) ? float3(ZERO, ONE, ZERO) : float3(ONE, ZERO, ONE);
    return lerp(rgb, tintColor, alpha);
}

float apply_hue(float h, float magnitude)
{
    return frac(h + magnitude * HUE_SCALE);
}

float3 LinearizeColor(float3 color)
{
    color = max(color, ZERO);
    return pow(color, GAMMA);
}

float3 ApplyGammaCorrection(float3 color)
{
    color = max(color, ZERO);
    return pow(color, INV_GAMMA);
}

float3 apply_black(float3 rgb, float magnitude)
{
    float B = magnitude * MAGNITUDE_SCALE_02;
    float luminance = calculate_luminance(rgb);
    float luminanceFactor = ONE - luminance;
    float adjusted_B = B * luminanceFactor;
    rgb = saturate(rgb - adjusted_B);
    return rgb;
}

float3 apply_white(float3 rgb, float magnitude)
{
    float W = magnitude * MAGNITUDE_SCALE_05;
    float luminance = calculate_luminance(rgb);
    float factor = pow(luminance, GAMMA_WHITE);
    rgb = saturate(rgb + W * factor);
    return rgb;
}

float3 apply_brightness(float3 rgb, float magnitude)
{
    float scale = (magnitude >= ZERO) ? BRIGHTNESS_MAGNITUDE_SCALE : MAGNITUDE_SCALE;
    float factor = ONE + magnitude * scale;
    return saturate(rgb * factor);
}

float3 apply_exposure(float3 rgb, float magnitude)
{
    magnitude *= EXPOSURE_MAGNITUDE_SCALE;
    float3 rgb_linear = LinearizeColor(rgb);
    float exposure_factor = pow(TWO, magnitude);
    rgb_linear *= exposure_factor;
    return saturate(ApplyGammaCorrection(rgb_linear));
}

float3 apply_contrast(float3 rgb, float magnitude)
{
    magnitude *= MAGNITUDE_SCALE;
    float contrast = ONE + magnitude;
    rgb = (rgb - CONTRAST_MIDPOINT) * contrast + CONTRAST_MIDPOINT;
    return saturate(rgb);
}

float3 apply_shadow(float3 rgb, float magnitude)
{
    float luminance = calculate_luminance(rgb);
    float adjusted_magnitude = magnitude * MAGNITUDE_SCALE;
    float shadow_mask = ONE - smoothstep(ZERO, HALF_CONST, luminance);
    float3 adjusted_rgb = pow(rgb, ONE - adjusted_magnitude * shadow_mask);
    return saturate(adjusted_rgb);
}

float3 apply_color_adjustments(float3 rgb)
{
    float3 hsl = rgb_to_hsl(rgb);
    hsl.x = apply_hue(hsl.x, HueMagnitude);
    hsl.y = apply_vibrance(hsl.y, VibranceMagnitude);
    hsl.y = apply_saturation(hsl.y, SaturationMagnitude);

    rgb = hsl_to_rgb(hsl);
    rgb = apply_black(rgb, BlackMagnitude);
    rgb = apply_white(rgb, WhiteMagnitude);
    rgb = apply_temperature(rgb, TemperatureMagnitude);
    rgb = apply_tint(rgb, TintMagnitude);
    rgb = apply_brightness(rgb, BrightnessMagnitude);
    rgb = apply_exposure(rgb, ExposureMagnitude);
    rgb = apply_contrast(rgb, ContrastMagnitude);
    rgb = apply_shadow(rgb, ShadowMagnitude);

    return rgb;
}

float3 apply_pixelate(uint2 id, float3 rgb, uint2 texSize)
{
    float blockSize_f;
    if (PixelateMagnitude != ZERO)
    {
        float maxBlockSize = (PixelateMagnitude > ZERO) ? MAX_BLOCK_SIZE : MIN_BLOCK_SIZE;
        blockSize_f = clamp(ONE + abs(PixelateMagnitude) * MAGNITUDE_SCALE * (maxBlockSize - ONE), ONE, maxBlockSize);
    }
    else
    {
        blockSize_f = ONE;
    }

    uint blockSize = max(1, (uint) (blockSize_f + HALF_CONST));
    uint2 blockCoord = (id / blockSize) * blockSize;
    blockCoord.x = min(blockCoord.x, texSize.x - 1);
    blockCoord.y = min(blockCoord.y, texSize.y - 1);

    return InputTexture[blockCoord].rgb;
}

float3 apply_sharpen(uint2 id, float3 rgb, uint2 texSize)
{
    int2 coord_left = int2(max(int(id.x) - 1, 0), int(id.y));
    int2 coord_right = int2(min(int(id.x) + 1, int(texSize.x) - 1), int(id.y));
    int2 coord_up = int2(int(id.x), max(int(id.y) - 1, 0));
    int2 coord_down = int2(int(id.x), min(int(id.y) + 1, int(texSize.y) - 1));

    float3 rgb_left = InputTexture[uint2(coord_left)].rgb;
    float3 rgb_right = InputTexture[uint2(coord_right)].rgb;
    float3 rgb_up = InputTexture[uint2(coord_up)].rgb;
    float3 rgb_down = InputTexture[uint2(coord_down)].rgb;
    float3 rgb_center = rgb;

    float3 laplacian = (rgb_center * FOUR) - (rgb_left + rgb_right + rgb_up + rgb_down);
    float alpha = SharpenMagnitude * MAGNITUDE_SCALE_09;
    float3 result_rgb = rgb;
 
    if (length(laplacian) > SHARPEN_THRESHOLD)
    {
        result_rgb += alpha * laplacian;
    }

    return saturate(result_rgb);
}

[numthreads(16, 16, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint2 texSize;
    InputTexture.GetDimensions(texSize.x, texSize.y);

    float4 pixel = InputTexture[id.xy];
    float3 rgb = pixel.rgb;
    
    rgb = apply_pixelate(id.xy, rgb, texSize);
    rgb = apply_sharpen(id.xy, rgb, texSize);
    rgb = apply_color_adjustments(rgb);

    Result[id.xy] = float4(rgb, pixel.a);
}